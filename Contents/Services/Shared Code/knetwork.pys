#!/usr/bin/env python

from io import open
from __builtin__ import getattr, hasattr, setattr
from threading import Thread, Event
from kbase import core, cache, paths
from kdomain import domain
from kutil import storage, util
from kheaders import Headers
from binascii import a2b_hex, a2b_base64
from crypto.cipher.aes_cbc import AES_CBC
import requests
import js2py

class network(object):
    def __init__(self):
        self.event = Event()
        self.stream_fp = None

    def raise_error_for_req(self, req):
        ourl = req.history[0].url if req.history else req.url

        http_error_msg = ''
        s = ''
        if isinstance(req.reason, requests.compat.bytes):
            try:
                reason = req.reason.decode('utf-8')
            except UnicodeDecodeError:
                reason = req.reason.decode('iso-8859-1')
        else:
            reason = req.reason

        if Regex(r'(/recaptcha)').search(req.text):
            http_error_msg = u'%s Server Error: %s for url: %s' % (req.status_code, 'Captcha Present!', ourl)
        elif util.is_kiss_url(ourl) and req.history:
            tt = util.get_tt(ourl)
            rburl = util.re_base_url.search(req.url).group(1)
            burl = util.re_base_url.search(ourl).group(1)
            if rburl != burl:
                domain.update(tt, True)

        if (400 <= req.status_code < 500):
            http_error_msg = u'%s Client Error: %s for url: %s' % (req.status_code, reason, ourl)
        elif (500 <= req.status_code < 600) and (503 != req.status_code):
            http_error_msg = u'%s Server Error: %s for url: %s' % (req.status_code, reason, ourl)
        elif 503 == req.status_code:
            try:
                Log.Critical("* <network.raise_error_for_req>: 503 Server Error: for url: {} >>>\n{}".format(ourl, req.text))
            except:
                Log.Error("* <network.raise_error_for_req>: 503 Server Error: for url: {}".format(ourl))
            http_error_msg = u'%s Server Error: %s for url: %s' % (req.status_code, reason, ourl)

        if http_error_msg:
            raise requests.exceptions.HTTPError(http_error_msg, response=self)

    def HTTPRequest(self, url, headers=None, data=None, follow_redirects=True, method='GET'):
        """not sure how to do this part yet"""

        if util.is_kiss_url(url):
            if not headers:
                headers = Headers.get_headers_for_url(url)
        nc = headers.get('cookie', None)
        cookies = dict((k,v) for (k,v) in Regex(r'(\w+)\=([^\;]+)').findall(nc)) if nc else {}

        r = requests
        rm = getattr(r, method.lower())
        try:
            req = rm(url, headers=headers, cookies=cookies, data=data, allow_redirects=follow_redirects)
            self.raise_error_for_req(req)
        except Exception as e:
            Log.Error(u"* <network.request> -error: cannot handle '{}' >>>\n{}".format(url, e))
            return None

        if ('k_token' in req.cookies) and nc:
            headers.update({'cookie': '; '.join([nc, 'k_token={}'.format(req.cookies['k_token'])])})
        if 'location' in req.headers.keys():
            headers['location'] = req.headers['location']
        if util.is_kiss_url(url):
            req.headers = headers
        return req

    def cache_hash(self, url):
        return Hash.MD5('kc_'+url)

    def cache_path(self, cache_dir):
        return storage.data_item_path(getattr(cache, cache_dir))

    def cache_list(self, cache_dir):
        path = self.cache_path(cache_dir)
        storage.ensure_dirs(path)
        return [f for f in storage.list_dir(path) if storage.file_exists(storage.join_path(path, f))]

    def rks_cache(self, url, rks=None, remove=False):
        name = self.cache_hash(url)
        for fn in self.cache_list('rks_cache_dir'):
            if fn != name:
                continue
            elif (fn == name) and remove:
                storage.remove(storage.RKS(fn))
                Log.Debug("* Removing RKS cache for '{}'".format(url))
                return False
            else:
                Log.Debug("* Fetching RKS '{}' from {}".format(url, cache.rks_cache_dir))
                return storage.load(storage.RKS(fn))
        if rks:
            Log.Debug("* Caching '{}' RKS to {}".format(url, cache.rks_cache_dir))
            storage.save(storage.RKS(name), rks)
            return rks
        return False

    def cache(self, url):
        name = self.cache_hash(url)
        path = self.cache_path('url_cache_dir')
        for fn in self.cache_list('url_cache_dir'):
            if fn != name:
                continue
            if (Datetime.FromTimestamp(storage.last_modified(storage.join_path(path, fn))) + util.timeout) <= Datetime.Now():
                Log.Debug("* Fetching fresh data for '{}'".format(url))
                self.rks_cache(url, remove=True)
                return
            else:
                Log.Debug("* Fetching '{}' from {}".format(url, cache.url_cache_dir))
                return storage.load(storage.HTTP(fn), True)
        return

    def Request(self, url, headers=None, data=None, follow_redirects=True, method='GET'):
        c = self.cache(url)
        if c:
            return c
        Log.Debug("* Caching '{}' HTTP to {}".format(url, cache.url_cache_dir))
        req = self.HTTPRequest(url, headers, data, follow_redirects, method)
        storage.save(storage.HTTP(self.cache_hash(url)), req, True)
        return req

    def ElementFromURL(self, url, headers=None, follow_redirects=True):
        return HTML.ElementFromString(self.Request(url, headers, follow_redirects=follow_redirects, method='GET').text)

    def setup_hash_fp(self, hash_name, fp):
        setattr(self, hash_name, fp)
        Log(fp)

    def stream_fpath(self, hash_name):
        return storage.data_item_path(storage.TMP(hash_name)+'.mp4')

    def check_stream_fp(self, hash_name):
        dir_path = storage.data_item_path(cache.tmp_cache_dir)
        storage.ensure_dirs(dir_path)
        return bool(storage.file_exists(self.stream_fpath(hash_name)))

    def save_stream(self, url, hash_name, headers=None):
        """
        Save images and videos
        Limit to videos for now...
        """
        #tt = util.get_tt(url) if util.get_tt(url) else 'Unknown'
        filepath = self.stream_fpath(hash_name)

        if self.check_stream_fp(hash_name):
            Log.Warn("* <network.save_stream[warn]>: filepath already exists - {}".format(filepath))
            self.setup_hash_fp(hash_name, filepath)
            self.event.set()  # end event
            return

        res = requests.get(url, headers=headers, stream=True)
        if (res.status_code != 200):
            Log.Error("* <network.save_stream[error(0)]>: HTTP {} Error for {}".format(res.status_code, url))
            self.event.set()  # end event
            return

        self.setup_hash_fp(hash_name, filepath)
        with open(filepath, 'wb') as f:
            for chunk in res.iter_content(chunk_size=1024):
            #for chunk in res.iter_content():
                if not chunk:
                    continue  # filter out keep-alive new chunks
                f.write(chunk)
        Log("* Finished saving Video Stream {} into {}".format(url, filepath))
        self.event.set()  # end event
        return

    def init_stream(self, url, headers=None, init=False):
        hash_name = self.cache_hash(url)
        Log(hash_name)
        if not self.check_stream_fp(hash_name):
            self.event.clear()

        if (init and url):
            self.event.clear()
            kwargs = {'hash_name': hash_name, 'headers': headers, 'url': url}
            self.que_thread = Thread(target=self.save_stream, kwargs=kwargs)
            self.que_thread.start()
        elif hasattr(self, 'que_thread') and self.event.is_set():
            Log("* <network.init_stream>: threaded download complete")
            #return (True, getattr(self, hash_name, None))
            #return (True, storage.data_item_path(storage.TMP(hash_name)+'.mp4'))
            return (True, self.stream_fpath(hash_name))
        elif hasattr(self, 'que_thread') and self.que_thread.is_alive():
            Log("* <network.init_stream>: still downloading stream")
        elif hasattr(self, 'que_thread') and not self.que_thread.is_alive():
            Log.Critical("* <network.init_stream[error(1)]>: thead failed to download stream. Please contact Twoure with issue.")
        else:
            Log("* <network.init_stream>: skip downloading a stream")
            #return (True, getattr(self, hash_name, None))
        return (False, self.stream_fpath(hash_name))

network = network()


class rks(object):
    def __init__(self):
        # kissasian
        di = String.Base64Decode("XzMyYjgxMmU5YTEzMjFhZTBlODRhZjY2MGM0NzIyYjNhXw==")[1:-1]
        self.div = a2b_hex(di)
        # kisscartoon
        ci = String.Base64Decode("X2E1ZThkMmU5YzE3MjFhZTBlODRhZDY2MGM0NzJjMWYzXw==")[1:-1]
        self.civ = a2b_hex(ci)
        # kissanime
        ai = String.Base64Decode("X2E1ZThkMmU5YzE3MjFhZTBlODRhZDY2MGM0NzJjMWYzXw==")[1:-1]
        self.aiv = a2b_hex(ai)
        # kissmanga
        mi = String.Base64Decode("X2E1ZThlMmU5YzI3MjFiZTBhODRhZDY2MGM0NzJjMWYzXw==")[1:-1]
        self.miv = a2b_hex(mi)

    def ensure_unicode(self, v):
        if isinstance(v, str):
            v = v.decode('utf8')
        return unicode(v)

    def dmm(self, tt):
        if tt == 'cartoon':
            params = String.Base64Decode('cmVkLHZlcnRpY2xlLGNlbnRlciw3OTI=').split(',')
        elif tt == 'drama':
            params = String.Base64Decode(
                'NjlkZTQwNzczNzY5YjE3YWMzNWQ5ZDdiYTQ3OWVjMWM0OTc5ZjkzNmUwMzdjZmZhM2I1YWZmOWRj'
                'MWNjYzIzMywxMTEsdmVydGljbGUtLDIxNQ=='
                ).split(',')
        else:
            return ''
        code = (
            "ZnVuY3Rpb24gYmNzKGEsIGIsIGMsIGQsIGUsIGYpIHsgdmFyIGcgPSAwOyBhICs9IGQ7IGMgKz0gYjsg"
            "ZCArPSBmOyBhICs9IGIgKyBjICsgZDsgZCArPSBlOyBiICs9IGQ7IGEgKz0gYiArIGQ7IGZvcih2YXIg"
            "aSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7IGcgKz0gYS5jaGFyQ29kZUF0KGkpIH0gcmV0dXJuIGcg"
            "fTsgZnVuY3Rpb24gZG1tKGMsIGQsIGUsIGYpIHsgdmFyIGcgPSAwOyBjICs9IGQgKyBmICsgZTsgZCAr"
            "PSAoZiArIGMpICogMjsgZSArPSBjICsgZCArIGY7IGMgKz0gKGMgKyBkICsgZSkgXiAyICsgTWF0aC5z"
            "cXJ0KGQpOyBkICs9IGJjcyhkLCBjLCBmLCBlLCBjICogMiwgZiAvIDIpOyBmb3IodmFyIGggPSBkLmxl"
            "bmd0aCAtIDE7IGggPj0gMDsgaC0tKSB7IGcgKz0gZC5jaGFyQ29kZUF0KGgpIH07IHJldHVybiBnIH07"
            )
        context = js2py.EvalJs()
        context.execute(String.Base64Decode(code))
        return context.dmm(*params)

    def get_base_rks(self, ttl, url, headers=dict, data=None):
        irks = network.rks_cache(url)
        if irks:
            return irks
        elif ttl == 'anime':
            return network.rks_cache(url, String.Base64Decode("X25oYXNhc2RiYXNkdGVuZTcyMzBhc2Jf")[1:-1])
        elif ttl == 'manga':
            return network.rks_cache(url, String.Base64Decode("X21zaHNkZjgzMm5zZGJhc2gyMGFzZG1f")[1:-1])
        try:
            headers.update({'X-Requested-With': 'XMLHttpRequest', 'Content-Length': '0'})
            if data:
                r = requests.post(util.get_base_url(url) + '/External/RSK', headers=headers, data=data)
            else:
                r = requests.post(util.get_base_url(url) + '/External/RSK', headers=headers)
            r.raise_for_status()
            return network.rks_cache(url, str(r.text))
        except:
            Log.Exception(u"* <network.get_base_rks> -error: Failed to retrieve RSK POST resquest >>>")
        return False

    def get_rks(self, url, headers=dict, data=None):
        ttl = util.get_tt(url).lower()
        irks = self.get_base_rks(ttl, url, headers, data)

        cl = list()
        fn = ""
        key = ""
        code = ""
        html = network.ElementFromURL(url)
        for node in html.xpath('//script[@type="text/javascript"]'):
            node = node.text_content().strip()
            rke = Regex(r'var\s*?(\_[^\=]+)\=\$kissenc').search(node)
            rcj = Regex(r'CryptoJS\.SHA256\(([^\)]+?)\)').search(node)
            if rke:
                key = rke.group(1)
                cl.append('var %s = "%s"; ' %(key, irks))
                continue
            elif rcj:
                key = rcj.group(1)
                for s in node.split(';'):
                    if 'CryptoJS' in s:
                        continue
                    cl.append(s+';')
                continue
            r2 = Regex(r'(\$kissenc[^\(]+\(%s\))' %key).search(node) if key else None
            if r2:
                continue
            r3 = Regex(r'(%s)' %key).search(node) if key else None
            if r3:
                rcl = list()
                bl = list()
                sc = len(node.split(';'))-1
                for i, n in enumerate(reversed(node.split(';'))):
                    n = n.strip()
                    if Regex(r'(%s)' %key).search(n):
                        r4 = Regex(r'\s([^\(\=]+)\(').search(n)
                        if r4:
                            fn = r4.group(1)
                        rcl.append(n.lstrip('} \n') + ';')
                    elif (i == sc):
                        r3 = Regex(r'var\s*?(\_[^\=]+)\=\[["\']([^"\']+)["\']\]').search(n)
                        if r3:
                            bl = [ String.Base64Decode(s.strip().decode('unicode_escape')) for s in r3.group(2).split(',') ]
                    elif fn and fn in n:
                        n = Regex(r'\_[^\+\=]+?\(.*?\)').sub(r"'bl_key'", n)
                        n = n + "}" if not n.endswith("}") else n
                        rcl.append(n.lstrip('} \n') + ';')
                rcl = [ s.replace('bl_key', (bl[0] if bl else '$')) for s in rcl ]
                cl = cl + list(reversed(rcl)) if rcl else cl

        if key and cl and irks and [ s for s in cl if Regex(r'(%s)' %key).findall(s) ]:
            cl = ['var %s = "%s";' %(key, irks)] + cl
        if key and cl:
            code = ''.join(cl + [' %s' %key]) if cl else ''

        if code and ('$' not in code):
            return js2py.eval_js(code)
        elif ('$' in code):
            Log.Error(u"* <rks.get_rks> - error: cannot find bl_key")

        Log.Warn(u"* <rks.get_rks> - error: cannot find final rks. Returning initial rks instead. >>>\n{}".format(code))
        return irks

    def Decode(self, f, ttl, key):
        if ttl == 'anime':
            iv = self.aiv
        elif ttl == 'cartoon':
            iv = self.civ
        elif ttl == 'drama':
            iv = self.div
        elif ttl == 'manga':
            iv = self.miv
        else:
            return False

        cipher = AES_CBC(key=Hash.SHA256(key, True), keySize=32)
        return self.ensure_unicode(cipher.decrypt(a2b_base64(f), iv))

    def decrypt(self, f, url, headers=None):
        data = None
        ttl = util.get_tt(url).lower()
        if (ttl == 'drama') or (ttl == 'cartoon'):
            data = {'krsk': self.dmm(ttl)}

        key = self.get_rks(url, headers, data)
        if key: return self.Decode(f, ttl, key)
        else: return
rks = rks()
