#!/usr/bin/env python

"""Kiss(anime, cartoon, and drama) Service code"""

# import Shared Service Code
#import common as Common
import metadata as Metadata
#from kissheaders import Headers
#from data import Data
#import js2py
from openload import OpenloadStreamFromURL
#from kissdecrypt import KissDecrypt
#from time import sleep
from io import open
import requests
import shutil

import kcore

RE_URL_OL = Regex(r'src\=["\'](https?://o(?:pen)?load.+?)["\']')
RE_URL_SM = Regex(r'src\=["\'](https?://stream\.moe/embed.+?)["\']')
RE_ENC_TEST = Regex(r'/Scripts/((?:kissenc|oran|subo)\.min\.j[^"\']+|vr\.j[^"\']+)')
RE_WINDOW1 = Regex(r'(?s)type\=["\']text/javascript["\']\>(.*?(window\[[^\=]+).*?)\</script\>')
RE_WINDOW2 = Regex(r'(.+window[^\=]+[^\;]+)')
RE_ITAG = Regex(r'itag\=(\d+)')
RE_ATOB = Regex(r'contents *?\= *?atob\(["\']([^"\']+)')

########################################################################################
def MetadataObjectForURL(url):

    Log('*' * 80)
    Log(u'* MetadataObjectForURL url = {}'.format(url))
    url = kcore.util.correct_url(url)

    video_id = int(url.split('=')[-1])
    show_url = url.rsplit('/', 1)[0]

    html = kcore.network.ElementFromURL(show_url)

    genres, genres_list = Metadata.GetGenres(html)
    date_added = Metadata.GetDateAdded(html, url)
    thumb = Callback(get_thumb, url=show_url)
    art = Metadata.get_art(url)

    # Setup MovieObject for Moives
    if 'Movie' in genres:
        Log('* -----Movie-----')

        # remove 'Movie' from genre list
        genre_list = [g for g in genres if not g == 'Movie']
        mi = Metadata.GetBaseMovieInfo(html, url)
        summary = unicode(kcore.util.string_code(string=mi['summary'], code='decode')) if mi['summary'] else None

        return MovieObject(
            title=mi['title'],
            genres=genre_list,
            tags=Metadata.string_to_list(kcore.util.string_code(string=mi['tags'], code='decode')) if mi['tags'] else [],
            source_title=mi['source_title'],
            originally_available_at=date_added if date_added else None,
            year=int(mi['year']) if mi['year'] else None,
            countries=Metadata.string_to_list(kcore.util.string_code(string=mi['countries'], code='decode')) if mi['countries'] else [],
            thumb=thumb,
            art=art,
            summary=summary
            )
    # Setup EpisodeObject for all shows that are not Movies
    else:
        Log('* -----TV Show-----')

        si = Metadata.GetBaseShowInfo(html, url)
        summary = unicode(kcore.util.string_code(string=si['summary'], code='decode')) if si['summary'] else None
        tags = Metadata.string_to_list(kcore.util.string_code(string=si['tags'], code='decode')) if si['tags'] else []
        show_name_raw = html.xpath('//div[@class="barContent"]/div/a[@class="bigChar"]/text()')[0]
        start_title = Metadata.get_title(html, video_id, show_name_raw)
        season_number = Metadata.GetSeasonNumber(start_title, show_name_raw, tags, summary)
        ep_name, ep_number = Metadata.GetEpisodeNameAndNumber(html, start_title, url)
        new_title = Metadata.GetEpisodeTitle(int(season_number), ep_name, int(ep_number))

        return EpisodeObject(
            title=new_title,
            source_title=si['source_title'],
            show=si['tv_show_name'],
            season=int(season_number),
            index=int(ep_number),
            tags=tags,
            originally_available_at=date_added if date_added else None,
            thumb=thumb,
            art=art,
            summary=summary
            )

########################################################################################
def MediaObjectsForURL(url):

    Log.Debug('*' * 80)
    fmt_list = [('1080', 'm37', 5000), ('720', 'm22', 2500), ('480', 'm59', 1125), ('360', 'm18', 650)]
    url = kcore.util.correct_url(url)

    # create media objects for each video quality
    if Prefs['force_transcode']:
        Log.Debug('* Force Transcoding ON')
        return [
            MediaObject(
                audio_channels=2,
                video_resolution=res,
                optimized_for_streaming=False,
                parts=[
                    PartObject(key=Callback(PlayVideo, url=url, m=m))
                    ],
                ) for res, m, b in fmt_list
            ]
    else:
        Log.Debug('* Force Trascoding OFF')
        return [
            MediaObject(
                bitrate=b,
                video_resolution=res,
                container=Container.MP4,
                video_codec=VideoCodec.H264,
                audio_codec=AudioCodec.AAC,
                audio_channels=2,
                optimized_for_streaming=True,
                parts=[
                    PartObject(key=Callback(PlayVideo, url=url, m=m))
                    ],
                ) for res, m, b in fmt_list
            ]

########################################################################################
@indirect
def PlayVideo(url, m, **kwargs):
    """
    Get Video URL
    Currently available host: GoogleVideo, Openload
    GoogleVideo links have the potential for multiple resolutions links
    Stream.moe:
        - used to be supported, but host site is currently offline
        - leaving code for now as it does not affect playback
    Openload, and Stream.moe give only one link (the highest), so no optional resolutions

    Video URL fallback system.
    Order as follows:
    * Preferred Server = KissNetwork
        KissNetwork --> Openload --> Stream.moe
    * Preferred Server = Openload
        Openload --> Stream.moe --> KissNetwork
    * Preferred Server = Stream
        Stream.moe --> KissNetwork
    """

    Log.Debug('*' * 80)
    Log.Debug('* Client.Product     = {}'.format(Client.Product))
    Log.Debug('* Client.Platform    = {}'.format(Client.Platform))
    Log.Debug('* Client.Version     = {}'.format(Client.Version))
    Log.Debug('* Channel.Server     = {}'.format(Prefs['server']))

    req_url = url + ('&s={}'.format(Prefs['server'].lower()) if Prefs['server'] != 'KissNetwork' else '')
    #vurl = get_video_url(url, m, *setup_video_page(req_url))
    vurl = get_video_url(url, m, kcore.network.Request(req_url))

    if (not vurl) and (Prefs['server'] == 'KissNetwork'):
        Log.Warn("* GoogleVideo URL offline, falling back to Openload")
        req_url = url + '&s=openload'
        #vurl = get_video_url(url, m, *setup_video_page(req_url))
        vurl = get_video_url(url, m, kcore.network.Request(req_url))

    if (not vurl) and (req_url.endswith('openload')):
        Log.Warn("* Openload URL offline, falling back to Stream.moe")
        req_url = url + '&s=stream'
        #vurl = get_video_url(url, m, *setup_video_page(req_url))
        vurl = get_video_url(url, m, kcore.network.Request(req_url))

    if (not vurl) and (req_url.endswith('stream')) and (Prefs['server'] != 'KissNetwork'):
        Log.Warn("* Stream.moe URL offline, falling back to KissNetwork")
        #vurl = get_video_url(url, m, *setup_video_page(url))
        vurl = get_video_url(url, m, kcore.network.Request(url))

    Log.Debug('* PlayVideo URL      = {}'.format(vurl))

    if Prefs['force_redirect'] and (Prefs['force_transcode'] == False) and (Prefs['server'] == 'KissNetwork'):
        Log.Debug('* Force Redirect ON')
        Log.Debug('* Note: Videos will NO longer play outside the network connection.')
        try:
            vurl = get_url_redirect_v2(vurl)
            if 'googlevideo' in vurl and not vurl == False:
                Log.Debug('* URL Redirect       = {}'.format(vurl.split('?')[0] + '...'))
            else:
                Log.Debug('* URL Redirect       = {}'.format(vurl))
        except:
            Log.Exception('* URL Redirect faild. Returning PlayVideo URL instead')
    else:
        Log.Debug('* Force Redirect OFF')

    Log.Debug('*' * 80)

    if vurl:
        if Prefs['server'] == 'Beta':
            http_headers = {'User-Agent': kcore.core.user_agent, 'Referer': req_url}
            return IndirectResponse(VideoClipObject, key=vurl, http_headers=http_headers)
        return IndirectResponse(VideoClipObject, key=vurl)

    raise Ex.MediaNotAvailable

########################################################################################
def setup_video_page(url):
    req = kcore.network.Request(url)
    return req.headers, req.text

########################################################################################
#def get_video_url(url, m, headers, page):
def get_video_url(url, m, resp):
    ol = RE_URL_OL.search(resp.text)
    st = RE_URL_SM.search(resp.text)
    if ol:
        Log.Debug('* OpenLoad URL       = {}'.format(ol.group(1)))
        vurl = get_openload_url(ol.group(1))
    elif st:
        Log.Debug('* StreamMoe URL      = {}'.format(st.group(1)))
        vurl = get_streammoe_url(st.group(1))
    else:
        vurl = get_googlevideo_url(url, m, resp)
    return vurl

####################################################################################################
#def get_googlevideo_url(page, url, m, headers):
def get_googlevideo_url(url, m, resp):
    """
    Get GoogleVideo URLs
    Returns the Hights stream playable depending on the previous Stream Selections
    If Stream not found, then try's to find next hightest.
    Example 1: format list = [1080p, 720p, 360p]
        If 480p was previously chosen, then 720p will be used
    Example 2: format list = [720p, 480p, 360p]
        If 1080p was previously chosen, then 720p will be used
    """

    page = resp.text
    headers = resp.headers
    html = HTML.ElementFromString(page)
    sQual = Regex(r'(id\="slcQualix")').search(page)
    olist = html.xpath('//select[@id="%s"]/option' %("slcQualix" if sQual else "selectQuality"))
    tt = kcore.util.get_tt(url)
    ttl = tt.lower()
    if not olist:
        Log.Error('* This Video is broken, Kiss{} is working to fix it.'.format(tt))
        raise Ex.MediaNotAvailable

    vurl = False
    vurls = list()
    # format info taken from here:
    # https://github.com/rg3/youtube-dl/blob/fd050249afce1bcc9e7f4a127069375467007b55/youtube_dl/extractor/youtube.py#L281
    # mp4 {format: resolution} dictionary
    fmt_dict = {'37': 1080, '22': 720, '59': 480, '78': 480, '18': 360}
    if Prefs['force_transcode']:
        # When force transcoding, then provide support for webm and flv video resolutions
        # webm {format: resolution} dictionary
        fmt_dict.update({'43': 360, '44': 480, '45': 720, '46': 1080})
        # flv {format: resolution} dictionary
        fmt_dict.update({'35': 480, '34': 360})
    # reversed mp4 format dictionary, paired values with resolutin selection in MediaObjectsForURL()
    rfmt_dict = {'1080': 37, '720': 22, '480': 59, '360': 18}

    enc_test = RE_ENC_TEST.search(page)
    if enc_test:
        Log.Debug('* {}'.format(enc_test.group(1)))

    for node in olist:
        if enc_test:
            #post_data = None
            #if (ttl != 'anime'):
            #    post_data = {'krsk': dmm(ttl)}
            #Log.Debug("* post_data = {}".format(post_data))

            #rks_init = get_rks_init(ttl, url, headers, post_data)
            #Log.Debug("* rks_init = {}".format(rks_init))
            #key = get_rks(ttl, page, rks_init)
            #Log.Debug("* key = {}".format(key))
            #vurl_old = KissDecrypt.decrypt(node.get('value'), ttl, key)

            vurl_old = kcore.rks.decrypt(node.get('value'), url, headers)
        else:
            vurl_old = String.Base64Decode(node.get('value'))

        if ('googlevideo' in vurl_old) or ('blogspot.com' in vurl_old):
            try:
                itag = vurl_old.split('=m')[1]
                vurls.append((vurl_old, fmt_dict[itag]))
            except:
                itag = 'No itag Found!'
                itag_test = RE_ITAG.search(vurl_old)
                if itag_test:
                    itag = str(itag_test.group(1))
                    if itag in fmt_dict.keys():
                        vurls.append((vurl_old, fmt_dict[itag]))
        else:
            try:
                res = node.text.strip()[:-1]
                itag = str(rfmt_dict[res])
                vurls.append((vurl_old, int(res)))
            except Exception as e:
                itag = u'No itag Found: {}'.format(e)

        if not itag in fmt_dict.keys():
            Log.Warn('* Format NOT Supported: {}'.format(itag))

    if vurls:
        Log.Debug('* pre resolution selected = {}'.format(m))
        for item, mm in Util.ListSortedByKey(vurls, 1):
            vurl = item
            nm = rfmt_dict[str(mm)]
            if nm == int(m[1:]):
                #Log.Debug('* Selecting {}p stream'.format(mm))
                break
            elif mm > fmt_dict[m[1:]]:
                #Log.Debug('* Selecting {}p stream'.format(mm))
                break
        Log.Debug('* Selecting {}p stream'.format(mm))

    if ((ttl == 'cartoon') or (ttl == 'drama') and ('Play?' in vurl)):
        Log.Debug(u"* Trying to get {} Redirect Link for '{}'".format(ttl, vurl))
        headers['referer'] = url
        vurl = get_url_redirect_v2(vurl, headers)

    return vurl

####################################################################################################
def get_openload_url(url):
    """
    Get OpenLoad URLs
    Code returns stream link for OpenLoad videos
    """

    http_headers = {'User-Agent': kcore.core.user_agent, 'Referer': url}
    ourl = OpenloadStreamFromURL(url, http_headers=http_headers)
    if ourl:
        rourl = get_url_redirect_v2(ourl, http_headers)
        return rourl

    Log.Error(u"* OpenloadStreamFromURL: cannot parse for stream '{}'".format(url))
    return False

####################################################################################################
def get_streammoe_url(moe_url):
    """Get Stream.moe URLs"""

    try:
        page = HTTP.Request(moe_url, cacheTime=CACHE_1MINUTE).content
    except:
        Log.Exception('* StreamMoe Error: >>>')
        return False

    r = RE_ATOB.search(page)
    if r:
        html_text = String.Base64Decode(r.group(1))
        html = HTML.ElementFromString(html_text)

        vurl = html.xpath('//source/@src')
        if vurl:
            return vurl[0]

    return False

####################################################################################################
def get_url_redirect_v2(input_url, http_headers=None):
    """URL Redirect V2 using requests.head"""

    if not http_headers:
        http_headers = {'User-Agent': kcore.core.user_agent, 'Referer': input_url}

    r = requests.head(input_url, headers=http_headers)
    if 'location' in r.headers.keys():
        return r.headers['location']
    elif 'Location' in r.headers.keys():
        return r.headers['Location']

    Log.Debug(u"* URL Redirect: No Redirect URL for '{}'".format(input_url))
    Log.Debug(u'* URL Redirect: Headers = {}'.format(r.headers))
    return input_url

########################################################################################
def get_thumb(url):
    thumb = None
    html = kcore.network.ElementFromURL(url)
    cover_url = kcore.util.correct_cover_image(html.xpath('//head/link[@rel="image_src"]/@href')[0])

    if kcore.util.is_kiss_url(cover_url):
        cover_file = cover_url.rsplit('/')[-1]
        tt = kcore.util.get_tt(url)
        if kcore.storage.cover_exists(kcore.storage.join_path(tt, cover_file)):
            return kcore.storage.data_object(kcore.storage.Covers(kcore.storage.join_path(tt, cover_file)))

        type_dir = kcore.storage.data_item_path(kcore.storage.Covers(tt))
        kcore.storage.ensure_dirs(type_dir)
        path = kcore.storage.join_path(type_dir, cover_file)
        Log("* file save path '{}'".format(path))

        if not kcore.storage.file_exists(path):
            r = requests.get(cover_url, headers=Headers.get_headers_for_url(cover_url), stream=True)
            if r.status_code == 200:
                with open(path, 'wb') as f:
                    r.raw.decode_content = True
                    shutil.copyfileobj(r.raw, f)
                Log("* Successfully saved '{}' in DataCovers".format(cover_url))
            else:
                Log.Error("* Save file requests status '{}'".format(r.status_code))
        else:
            Log.Warn('* Cover file already exists, Skipped file save.')

        if kcore.storage.cover_exists(kcore.storage.join_path(tt, cover_file)):
            return kcore.storage.data_object(kcore.storage.Covers(kcore.storage.join_path(tt, cover_file)))

        Log.Error("* Issues loading '{}'".format(path))
    elif 'http' in cover_url:
        thumb = Redirect(cover_url)
    else:
        Log.Error('*' * 80)
        Log.Error('* cover url not a valid picture url | {}'.format(cover_url))
        Log.Error('*' * 80)

    return thumb
